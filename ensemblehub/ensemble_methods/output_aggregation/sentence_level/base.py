"""
Base class for sentence-level aggregation methods.
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Tuple, Union
import logging

logger = logging.getLogger(__name__)


class ModelAttribution:
    """Track which model generated each segment of text."""
    
    def __init__(self):
        self.segments = []  # List of (text_segment, model_name, round_number)
        self.current_round = 0
    
    def add_segment(self, text: str, model_name: str, round_num: int = None):
        """Add a text segment with its generating model."""
        if round_num is None:
            round_num = self.current_round
        self.segments.append({
            "text": text,
            "model": model_name,
            "round": round_num,
            "length": len(text)
        })
    
    def get_attribution_summary(self) -> str:
        """Get a formatted summary of model attributions."""
        if not self.segments:
            return "No attribution data available"
        
        summary = []
        for i, seg in enumerate(self.segments):
            model_short = seg["model"].split("/")[-1] if "/" in seg["model"] else seg["model"]
            summary.append(f"[R{seg['round']:02d}:{model_short}]")
        
        return " → ".join(summary)
    
    def get_detailed_attribution(self) -> List[Dict]:
        """Get detailed attribution information."""
        return self.segments.copy()
    
    def format_text_with_attribution(self, show_boundaries: bool = True) -> str:
        """Format text with model attribution markers."""
        if not self.segments:
            return ""
        
        result = []
        for i, seg in enumerate(self.segments):
            if show_boundaries and i > 0:
                result.append("\n")
            
            model_short = seg["model"].split("/")[-1] if "/" in seg["model"] else seg["model"]
            result.append(f"<!-- Generated by {model_short} (Round {seg['round']}) -->\n")
            result.append(seg["text"])
        
        return "".join(result)


class BaseSentenceAggregator(ABC):
    """
    Abstract base class for sentence-level output aggregation.
    
    Sentence-level aggregation selects the best sentence/segment from multiple
    model outputs at each generation step.
    """
    
    def __init__(self, name: str = None):
        self.name = name or self.__class__.__name__
        self.attribution = ModelAttribution()
    
    @abstractmethod
    def select_best_sentence(
        self,
        sentences: List[str],
        generators: List,
        prompt: str,
        scorers = None,
        **kwargs
    ) -> Tuple[int, str, float]:
        """
        Select the best sentence from multiple candidates.
        
        Args:
            sentences: List of candidate sentences from different models
            generators: List of generator models
            prompt: Current prompt/context
            scorers: Scorer pool for evaluation
            **kwargs: Additional arguments
            
        Returns:
            Tuple of (best_index, best_sentence, score)
        """
        pass
    
    @abstractmethod
    def aggregate_generation(
        self,
        generators: List,
        scorers,
        examples: List[Union[str, List[Dict]]],  # 批处理输入
        max_rounds: int = 500,
        score_threshold: float = -2.0,
        **kwargs
    ) -> str:
        """
        Run iterative sentence-level aggregation generation.
        
        Args:
            generators: List of generator models
            scorers: Scorer pool for evaluation
            example: Input example
            max_rounds: Maximum generation rounds
            score_threshold: Score threshold for early stopping
            **kwargs: Additional arguments
            
        Returns:
            Generated text
        """
        pass
    
    def get_attribution_data(self) -> Dict[str, Any]:
        """Get model attribution data for the last generation."""
        return {
            "summary": self.attribution.get_attribution_summary(),
            "detailed": self.attribution.get_detailed_attribution(),
            "formatted_text": self.attribution.format_text_with_attribution()
        }
    
    def __repr__(self):
        return f"{self.__class__.__name__}(name='{self.name}')"
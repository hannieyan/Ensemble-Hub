"""
Base class for sentence-level aggregation methods.
"""

from abc import ABC, abstractmethod
from typing import List, Dict, Any, Tuple, Union
import logging

logger = logging.getLogger(__name__)


class ModelAttribution:
    """Track which model generated each segment of text."""
    
    def __init__(self):
        self.segments = []  # List of (text_segment, model_name, round_number)
        self.current_round = 0
    
    def add_segment(self, text: str, model_name: str, token_count: int, round_num: int = None):
        """Add a text segment with its generating model.
        
        Args:
            text: The generated text
            model_name: Name of the model that generated this text
            round_num: The round number (default: current_round)
            token_count: Number of tokens in the text (if None, will store character count)
        """
        if round_num is None:
            round_num = self.current_round
        self.segments.append({
            "text": text,
            "model": model_name,
            "round": round_num,
            "length": token_count,
        })
    
    def get_attribution_summary(self) -> str:
        """Get a formatted summary of model attributions."""
        if not self.segments:
            return "No attribution data available"
        
        summary = []
        for i, seg in enumerate(self.segments):
            model_short = seg["model"].split("/")[-1] if "/" in seg["model"] else seg["model"]
            summary.append(f"[R{seg['round']:02d}:{model_short}]")
        
        return " → ".join(summary)
    
    def get_detailed_attribution(self) -> List[Dict]:
        """Get detailed attribution information."""
        return self.segments.copy()
    
    def format_text_with_attribution(self, show_boundaries: bool = True) -> str:
        """Format text with model attribution markers."""
        if not self.segments:
            return ""
        
        result = []
        for i, seg in enumerate(self.segments):
            if show_boundaries and i > 0:
                result.append("\n")
            
            model_short = seg["model"].split("/")[-1] if "/" in seg["model"] else seg["model"]
            result.append(f"<!-- Generated by {model_short} (Round {seg['round']}) -->\n")
            result.append(seg["text"])
        
        return "".join(result)


class BaseSentenceAggregator(ABC):
    """
    Abstract base class for sentence-level output aggregation.
    
    Sentence-level aggregation selects the best sentence/segment from multiple
    model outputs at each generation step.
    """
    
    def __init__(self, name: str = None):
        self.name = name or self.__class__.__name__
        self.attribution = ModelAttribution()

    
    @abstractmethod
    def aggregate_generation(
        self,
        generators: List,
        scorers,
        examples: List[Union[str, List[Dict]]],  # 批处理输入
        max_rounds: int = 500,
        score_threshold: float = -2.0,
        **kwargs
    ) -> str:
        """
        Run iterative sentence-level aggregation generation.
        
        Args:
            generators: List of generator models
            scorers: Scorer pool for evaluation
            example: Input example
            max_rounds: Maximum generation rounds
            score_threshold: Score threshold for early stopping
            **kwargs: Additional arguments
            
        Returns:
            Generated text
        """
        pass
    
    def get_attribution_data(self) -> List[Dict[str, Any]]:
        """Get model attribution data for the last generation.
        
        Returns:
            List of attribution data, one dict per example in the batch.
            Default implementation returns empty list since most aggregators
            don't track per-example attribution.
        """
        return []
    
    def __repr__(self):
        return f"{self.__class__.__name__}(name='{self.name}')"